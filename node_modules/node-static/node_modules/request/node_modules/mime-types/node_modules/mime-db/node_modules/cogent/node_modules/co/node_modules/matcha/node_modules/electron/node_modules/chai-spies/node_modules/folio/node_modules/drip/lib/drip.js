/*!
 * drip - Node.js event emitter.
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * concat (arr1, arr2(
 *
 * A much faster concat for two arrays.
 * Returns a new array.
 *
 * @param {Array} first array
 * @param {Array} second array
 * @returns {Array} combined
 * @api private
 */

function concat (arr1, arr2) {
  var l1 = arr1.length
    , l2 = arr2.length
    , res = Array(l1 + l2);
  for (var i = 0; i < l1; i++) res[i] = arr1[i];
  for (var i2 = 0; i2 < l2; i2++) res[i + i2] = arr2[i2];
  return res;
}


/*!
 * primary module export
 */

var exports = module.exports = Drip;

/*!
 * version export
 */

exports.version = '0.3.1';

/**
 * ## Drip API
 *
 * Create new instance of drip. Can also be easily
 * be used as the basis for other objects.
 *
 *     var drop = new Drip();
 *
 *
 * Namespacing is off by default. To turn it on, use
 * the `delimeter` option, indicating what delimeter will
 * be used if you choose to listen by string. The recommended
 * standard is `:` or `::`.
 *
 *     // for namespaced events
 *     var drop = new Drip({ delimeter: ':' });
 *
 * You can also use drip as the basis for your own objects.
 * To do so, simply call the drip function on construction
 * inherit it's methods. This node pattern is the recommended
 * method.
 *
 *     function MyConstructor () {
 *       Drip.call(this, { delimeter: '::' });
 *       // etc
 *     }
 *
 *     util.inherits(MyConstructor, Drip);
 *
 * @header Drip API
 */

function Drip (opts) {
  /*!
   * @param {Object} options
   * @api public
   */

  if (opts) {
    // storage
    this._drip = {};
    this._drip.delimeter = opts.delimeter || ':';
    this._drip.wildcard = opts.wildcard || (opts.delimeter ? true : false);

    // toggle functions
    if (this._drip.wildcard) {
      this.on = onWildcard;
      this.off = offWildcard;
      this.emit = emitWildcard;
      this.hasListener  = hasWildcard;
    }
  }
}

/**
 * ### .on (event, callback)
 *
 * Bind a `callback` function to all emits of `event`.
 * Wildcards `*`, will be executed for every event at
 * that level of heirarchy.
 *
 *     // for simple drips
 *     drop.on('foo', callback);
 *
 *     // for delimeted drips
 *     drop.on('foo:bar', callback);
 *     drop.on([ 'foo', 'bar' ], callback);
 *     drop.on('foo:*', callback);
 *     drop.on([ 'foo', '*' ], callback);
 *
 * An array can be passed for event when a delimeter has been
 * defined. Events can also have as many levels as you like.
 *
 * @param {String|Array} event
 * @param {Function} callback
 * @name on
 * @alias addListener
 * @api public
 */

Drip.prototype.on = onSimple;

/*!
 * `on` for non-wildcard drip instances
 */

function onSimple () {
  var map = this._events || (this._events = {})
    , ev = arguments[0]
    , fn = arguments[1];
  if (!map[ev]) map[ev] = fn;
  else if ('function' === typeof map[ev]) map[ev] = [ map[ev], fn ];
  else map[ev].push(fn);
  return this;
}

/*!
 * `on` for wildcard drip instances
 */

function onWildcard () {
  var map = this._events || (this._events = {})
    , ev = arguments[0]
    , fn = arguments[1]
    , evs = Array.isArray(ev)
      ? ev.slice(0)
      : ev.split(this._drip.delimeter)
    , store = this._events || (this._events = {});

  function traverse (events, map) {
    var event = events.shift();
    map[event] = map[event] || {};

    if (events.length) {
      traverse(events, map[event]);
    } else {
      if (!map[event]._) map[event]._= [ fn ];
      else map[event]._.push(fn);
    }
  };

  traverse(evs, store);
  return this;